#!/usr/bin/env bash
#
# orchestrate - Simple multi-agent orchestrator using Claude Code SDK
#
# Supports git worktrees for isolated parallel development.
# Only ONE PR open at a time - queue system for finished work.
#
# Usage:
#   ./orchestrate develop <task>          - Develop in worktree
#   ./orchestrate pr create               - Create PR from finished work
#   ./orchestrate pr queue                - Show queued finished work
#   ./orchestrate pr status               - Check current PR status
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKTREE_DIR="${WORKTREE_DIR:-$SCRIPT_DIR/.worktrees}"
STATE_DIR="${STATE_DIR:-$SCRIPT_DIR/.orchestrate}"
QUEUE_FILE="$STATE_DIR/pr-queue"
CURRENT_PR_FILE="$STATE_DIR/current-pr"

# Check Claude CLI
command -v claude &>/dev/null || {
    echo "Error: Claude CLI not found"
    echo "Install: https://docs.anthropic.com/en/docs/claude-code"
    exit 1
}

mkdir -p "$STATE_DIR"

# ==================== PR Queue Functions ====================

# Check if there's an open PR
pr_is_open() {
    [[ -f "$CURRENT_PR_FILE" ]] || return 1
    local pr_num=$(cat "$CURRENT_PR_FILE")
    local state=$(gh pr view "$pr_num" --json state -q '.state' 2>/dev/null || echo "UNKNOWN")
    [[ "$state" == "OPEN" ]]
}

# Get current open PR number
pr_current() {
    [[ -f "$CURRENT_PR_FILE" ]] && cat "$CURRENT_PR_FILE"
}

# Add worktree to PR queue (finished work waiting for PR)
queue_add() {
    local wt_name="$1"
    local title="${2:-$wt_name}"
    echo "$wt_name|$title|$(date +%s)" >> "$QUEUE_FILE"
    echo "Queued: $wt_name"
}

# Show PR queue
queue_list() {
    echo "=== PR Queue ==="
    if [[ -f "$QUEUE_FILE" ]] && [[ -s "$QUEUE_FILE" ]]; then
        local i=1
        while IFS='|' read -r name title ts; do
            echo "  $i. $name - $title"
            ((i++))
        done < "$QUEUE_FILE"
    else
        echo "  (empty)"
    fi
    echo ""
    echo "=== Current PR ==="
    if pr_is_open; then
        local pr_num=$(pr_current)
        echo "  PR #$pr_num (OPEN)"
        gh pr view "$pr_num" --json title,url -q '"  " + .title + "\n  " + .url' 2>/dev/null || true
    else
        echo "  (none)"
    fi
}

# Get next from queue
queue_next() {
    [[ -f "$QUEUE_FILE" ]] && [[ -s "$QUEUE_FILE" ]] || return 1
    head -1 "$QUEUE_FILE" | cut -d'|' -f1
}

# Remove first from queue
queue_pop() {
    [[ -f "$QUEUE_FILE" ]] || return 0
    tail -n +2 "$QUEUE_FILE" > "$QUEUE_FILE.tmp"
    mv "$QUEUE_FILE.tmp" "$QUEUE_FILE"
}

# Create PR from worktree (only if no open PR)
pr_create() {
    local wt_name="${1:-}"

    # Check if PR is already open
    if pr_is_open; then
        local pr_num=$(pr_current)
        echo "PR #$pr_num is still open. Wait for it to close."
        echo "Use: orchestrate pr status"
        return 1
    fi

    # Get from queue if not specified
    if [[ -z "$wt_name" ]]; then
        wt_name=$(queue_next) || {
            echo "No work in queue. Use: orchestrate pr queue"
            return 1
        }
    fi

    local wt_path="$WORKTREE_DIR/$wt_name"
    [[ -d "$wt_path" ]] || { echo "Worktree not found: $wt_name"; return 1; }

    echo "Creating PR from: $wt_name"
    cd "$wt_path"

    # Push branch
    local branch=$(git rev-parse --abbrev-ref HEAD)
    git push -u origin "$branch" 2>/dev/null || git push origin "$branch"

    # Create PR
    local pr_url=$(gh pr create --fill 2>/dev/null || gh pr create --title "$wt_name" --body "From worktree: $wt_name")
    local pr_num=$(echo "$pr_url" | grep -oE '[0-9]+$')

    # Save current PR
    echo "$pr_num" > "$CURRENT_PR_FILE"

    # Remove from queue
    queue_pop

    echo "Created PR #$pr_num: $pr_url"
    echo ""
    echo "Shepherd will watch: orchestrate shepherd $pr_num"
}

# Check PR status and process queue if closed
pr_check() {
    if ! pr_is_open; then
        # Clear current PR
        rm -f "$CURRENT_PR_FILE"

        # Check if queue has items
        if queue_next &>/dev/null; then
            echo "Previous PR closed. Creating next from queue..."
            pr_create
        else
            echo "No open PR. Queue is empty."
        fi
    else
        local pr_num=$(pr_current)
        echo "PR #$pr_num is open"
        gh pr view "$pr_num" --json state,statusCheckRollup,reviews \
            -q '"State: " + .state + "\nChecks: " + (.statusCheckRollup | map(.conclusion) | join(", "))' 2>/dev/null || true
    fi
}

# Mark worktree as done and queue for PR
mark_done() {
    local wt_name="$1"
    local title="${2:-$wt_name}"

    local wt_path="$WORKTREE_DIR/$wt_name"
    [[ -d "$wt_path" ]] || { echo "Worktree not found: $wt_name"; return 1; }

    # Ensure all changes committed
    cd "$wt_path"
    if [[ -n $(git status --porcelain) ]]; then
        echo "Uncommitted changes in $wt_name. Commit first."
        return 1
    fi

    # Add to queue
    queue_add "$wt_name" "$title"

    # Try to create PR if none open
    if ! pr_is_open; then
        echo "No open PR. Creating now..."
        pr_create "$wt_name"
    else
        echo "PR queue position: $(wc -l < "$QUEUE_FILE" | tr -d ' ')"
    fi
}

# ==================== Worktree Functions ====================

worktree_create() {
    local name="$1"
    local base="${2:-main}"
    local branch="worktree/$name"
    local path="$WORKTREE_DIR/$name"

    mkdir -p "$WORKTREE_DIR"

    git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null || \
        git branch "$branch" "$base"

    git worktree add "$path" "$branch" 2>/dev/null || {
        echo "Worktree exists: $path" >&2
    }

    echo "$path"
}

worktree_remove() {
    local name="$1"
    local path="$WORKTREE_DIR/$name"

    git worktree remove "$path" --force 2>/dev/null || true
    git branch -D "worktree/$name" 2>/dev/null || true
    echo "Removed: $name"
}

worktree_list() {
    echo "Worktrees:"
    git worktree list
}

# ==================== Main Commands ====================

cmd="${1:-interactive}"
shift 2>/dev/null || true

case "$cmd" in
    # ==================== PR Commands ====================
    pr)
        subcmd="${1:-status}"
        shift 2>/dev/null || true
        case "$subcmd" in
            set|watch)
                [[ $# -lt 1 ]] && { echo "Usage: $0 pr set <pr_number>"; exit 1; }
                pr_num="$1"
                # Verify PR exists
                if ! gh pr view "$pr_num" &>/dev/null; then
                    echo "PR #$pr_num not found"
                    exit 1
                fi
                echo "$pr_num" > "$CURRENT_PR_FILE"
                echo "Set current PR to #$pr_num"
                gh pr view "$pr_num" --json title,state,url -q '"Title: " + .title + "\nState: " + .state + "\nURL: " + .url'
                ;;
            create)
                pr_create "$@"
                ;;
            queue|list)
                queue_list
                ;;
            status|check)
                pr_check
                ;;
            next)
                pr_create
                ;;
            clear)
                rm -f "$CURRENT_PR_FILE"
                echo "Cleared current PR"
                ;;
            *)
                echo "PR commands: set, create, queue, status, next, clear"
                ;;
        esac
        ;;

    done|finish)
        [[ $# -lt 1 ]] && { echo "Usage: $0 done <worktree_name> [title]"; exit 1; }
        mark_done "$@"
        ;;

    # ==================== Worktree Commands ====================
    worktree|wt)
        subcmd="${1:-list}"
        shift 2>/dev/null || true
        case "$subcmd" in
            create|new)
                [[ $# -lt 1 ]] && { echo "Usage: $0 wt create <name> [base]"; exit 1; }
                worktree_create "$@"
                ;;
            remove|rm)
                [[ $# -lt 1 ]] && { echo "Usage: $0 wt remove <name>"; exit 1; }
                worktree_remove "$1"
                ;;
            list|ls)
                worktree_list
                ;;
            *)
                echo "Worktree commands: create, remove, list"
                ;;
        esac
        ;;

    # ==================== BMAD Commands ====================
    bmad)
        epic="${1:-}"
        wt_name="${2:-bmad-$(date +%s)}"

        wt_path=$(worktree_create "$wt_name")
        echo "Working in: $wt_path"
        cd "$wt_path"

        if [[ -n "$epic" ]]; then
            claude -p "Use the Task tool with subagent_type=\"bmad-orchestrator\" to run BMAD workflow for epic: $epic

Working directory: $wt_path

Follow BMAD method:
1. Find the epic in docs/bmad/epics/
2. Break into stories
3. Implement each story with TDD
4. Review code
5. When done, tell user to run: orchestrate done $wt_name" --dangerously-skip-permissions
        else
            claude -p "Use the Task tool with subagent_type=\"bmad-orchestrator\" to:
1. List available epics in docs/bmad/epics/
2. Show their status
3. Ask which epic to work on

Working directory: $wt_path" --dangerously-skip-permissions
        fi
        ;;

    bmad-plan|plan)
        [[ $# -lt 1 ]] && { echo "Usage: $0 plan <feature>"; exit 1; }
        claude -p "Use the Task tool with subagent_type=\"bmad-planner\" to create a BMAD epic and stories for: $*

Create in docs/bmad/:
- Epic file with overview
- Story files with acceptance criteria" --dangerously-skip-permissions
        ;;

    bmad-story|story)
        [[ $# -lt 1 ]] && { echo "Usage: $0 story <story_id> [wt_name]"; exit 1; }
        story_id="$1"
        wt_name="${2:-story-$story_id}"

        wt_path=$(worktree_create "$wt_name")
        echo "Working in: $wt_path"
        cd "$wt_path"

        claude -p "Use the Task tool with subagent_type=\"story-developer\" to implement BMAD story: $story_id

Working directory: $wt_path

Follow TDD. When done, tell user to run: orchestrate done $wt_name" --dangerously-skip-permissions
        ;;

    # ==================== Core Commands ====================
    shepherd|sh)
        [[ $# -lt 1 ]] && { echo "Usage: $0 shepherd <pr_number>"; exit 1; }
        pr_num="$1"
        wt_name="pr-$pr_num"

        # Get PR branch name
        pr_branch=$(gh pr view "$pr_num" --json headRefName -q '.headRefName')

        # Fetch the branch
        git fetch origin "$pr_branch" 2>/dev/null || true

        # Create worktree from PR branch
        wt_path="$WORKTREE_DIR/$wt_name"
        mkdir -p "$WORKTREE_DIR"

        # Prune stale worktrees first
        git worktree prune 2>/dev/null || true

        if [[ ! -d "$wt_path" ]]; then
            git worktree add "$wt_path" "origin/$pr_branch" 2>/dev/null || \
                git worktree add -f "$wt_path" "origin/$pr_branch" 2>/dev/null || \
                git worktree add "$wt_path" "$pr_branch" 2>/dev/null || {
                    echo "Failed to create worktree for PR #$pr_num"
                    exit 1
                }
        fi

        echo "Working in: $wt_path"
        cd "$wt_path"

        # Set as current PR
        echo "$pr_num" > "$CURRENT_PR_FILE"

        # Log file for output
        LOG_FILE="$STATE_DIR/shepherd-$pr_num.log"
        echo "=== Shepherd started: $(date) ===" >> "$LOG_FILE"
        echo "Agent output: $LOG_FILE"

        # Get repo info for GraphQL queries
        repo_info=$(gh repo view --json owner,name -q '.owner.login + "/" + .name')
        repo_owner=$(echo "$repo_info" | cut -d'/' -f1)
        repo_name=$(echo "$repo_info" | cut -d'/' -f2)

        # Run claude
        claude -p "You are a PR shepherd. Fix ALL issues on PR #$pr_num NOW.

Working directory: $wt_path
PR branch: $pr_branch
Repository: $repo_owner/$repo_name

## STEP 1 - GET UNRESOLVED REVIEW THREADS:

gh api graphql -f query='query { repository(owner: \"$repo_owner\", name: \"$repo_name\") { pullRequest(number: $pr_num) { reviewThreads(first: 100) { nodes { id isResolved path line comments(first: 1) { nodes { body author { login } } } } } } } }' --jq '.data.repository.pullRequest.reviewThreads.nodes | map(select(.isResolved == false))'

## STEP 2 - FOR EACH UNRESOLVED THREAD:

1. Read the comment body to understand what change is requested
2. Make the code fix if needed
3. Reply to the comment explaining your fix:
   gh pr comment $pr_num --body 'Fixed: explanation here'
4. RESOLVE THE THREAD (CRITICAL - this is required to merge):
   gh api graphql -f query='mutation { resolveReviewThread(input: {threadId: \"THE_THREAD_ID\"}) { thread { isResolved } } }'

The thread ID looks like: PRRT_kwDONOK... - get it from the query in Step 1.

## STEP 3 - CHECK AND FIX CI:

gh pr checks $pr_num
If any fail, check logs and fix: gh run view RUN_ID --log-failed

## STEP 4 - COMMIT AND PUSH:

git add -A && git commit -m 'fix: address review feedback' && git push

## REQUIREMENTS:
- RESOLVE ALL threads (not just reply)
- All CI checks must pass
- Actually FIX code, don't just report

After each thread resolution, verify it worked:
gh api graphql -f query='query { repository(owner: \"$repo_owner\", name: \"$repo_name\") { pullRequest(number: $pr_num) { reviewThreads(first: 100) { nodes { isResolved } } } } }' --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length'

Keep going until that returns 0." --dangerously-skip-permissions 2>&1 | tee -a "$LOG_FILE"
        ;;

    develop|dev)
        [[ $# -lt 1 ]] && { echo "Usage: $0 dev <task> [wt_name]"; exit 1; }
        task="$1"
        wt_name="${2:-dev-$(date +%s)}"

        wt_path=$(worktree_create "$wt_name")
        echo "Working in: $wt_path"
        cd "$wt_path"

        claude -p "Use the Task tool with subagent_type=\"story-developer\" to implement: $task

Working directory: $wt_path

When done, tell user to run: orchestrate done $wt_name" --dangerously-skip-permissions
        ;;

    review|rev)
        [[ $# -lt 1 ]] && { echo "Usage: $0 review <target>"; exit 1; }
        claude -p "Use the Task tool with subagent_type=\"code-reviewer\" to review: $*" --dangerously-skip-permissions
        ;;

    parallel|par)
        [[ $# -lt 2 ]] && { echo "Usage: $0 parallel <task1> <task2> ..."; exit 1; }
        prompt="Spawn these agents IN PARALLEL using multiple Task tool calls in ONE message:"
        i=1
        for task in "$@"; do
            wt_path=$(worktree_create "parallel-$i-$(date +%s)")
            prompt+=$'\n'"- Use Task with subagent_type=\"explorer\" in $wt_path to: $task"
            ((i++))
        done
        claude -p "$prompt" --dangerously-skip-permissions
        ;;

    spawn)
        [[ $# -lt 2 ]] && { echo "Usage: $0 spawn <agent> <task> [wt_name]"; exit 1; }
        agent="$1"; shift
        task="$1"; shift
        wt_name="${1:-$agent-$(date +%s)}"

        wt_path=$(worktree_create "$wt_name")
        echo "Working in: $wt_path"
        cd "$wt_path"

        claude -p "Use the Task tool with subagent_type=\"$agent\" to: $task

Working directory: $wt_path" --dangerously-skip-permissions
        ;;

    # ==================== Automated Loop ====================
    loop)
        LOOP_INTERVAL="${LOOP_INTERVAL:-30}"
        MAX_CONCURRENT_SHEPHERDS="${MAX_CONCURRENT_SHEPHERDS:-3}"
        WORK_LOCK="$STATE_DIR/work.lock"

        # Cleanup locks on exit
        trap 'rm -f "$STATE_DIR"/shepherd-*.lock "$WORK_LOCK" 2>/dev/null' EXIT

        # ASCII UI display function
        display_status() {
            local repo_owner="$1"
            local repo_name="$2"

            clear
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘                        ðŸ¤– ORCHESTRATE - Multi-Agent Loop                     â•‘"
            echo "â•‘                              $repo_owner/$repo_name"
            printf "â•‘%78sâ•‘\n" ""
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘  â° $(date '+%Y-%m-%d %H:%M:%S')                    Interval: ${LOOP_INTERVAL}s  Max Agents: $MAX_CONCURRENT_SHEPHERDS  â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘                              ðŸ“‹ PULL REQUESTS                                â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘   PR   â•‘             Title                 â•‘  Threads   â•‘      Status        â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"

            for pr_num in $open_prs; do
                # Get PR title
                pr_title=$(gh pr view "$pr_num" --json title -q '.title' 2>/dev/null | cut -c1-33)

                # Get unresolved count
                unresolved=$(gh api graphql -f query='
                    query { repository(owner: "'"$repo_owner"'", name: "'"$repo_name"'") {
                        pullRequest(number: '"$pr_num"') {
                            reviewThreads(first: 100) { nodes { isResolved } }
                        }
                    } }' --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length' 2>/dev/null || echo "?")

                # Check shepherd status
                local lock_file="$STATE_DIR/shepherd-$pr_num.lock"
                local status_icon status_text
                if [[ -f "$lock_file" ]] && kill -0 "$(cat "$lock_file" 2>/dev/null)" 2>/dev/null; then
                    status_icon="ðŸ”„"
                    status_text="Shepherd running"
                elif [[ "$unresolved" == "0" ]]; then
                    status_icon="âœ…"
                    status_text="Healthy"
                else
                    status_icon="â³"
                    status_text="Pending"
                fi

                printf "â•‘  #%-4s â•‘ %-33s â•‘     %-6s â•‘ %s %-14s â•‘\n" \
                    "$pr_num" "$pr_title" "$unresolved" "$status_icon" "$status_text"
            done

            echo "â• â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘                              ðŸ¤– ACTIVE AGENTS                                  â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"

            local agent_count=0
            shopt -s nullglob 2>/dev/null || true
            for lock_file in "$STATE_DIR"/shepherd-*.lock; do
                [[ -f "$lock_file" ]] || continue
                local pid=$(cat "$lock_file" 2>/dev/null)
                if kill -0 "$pid" 2>/dev/null; then
                    local pr_num=$(basename "$lock_file" .lock | sed 's/shepherd-//')
                    local runtime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ' || echo "??:??")
                    printf "â•‘  ðŸ‘ Shepherd #%-4s â”‚ PID: %-8s â”‚ Runtime: %-10s â”‚ Working...       â•‘\n" \
                        "$pr_num" "$pid" "$runtime"
                    ((agent_count++)) || true
                fi
            done
            shopt -u nullglob 2>/dev/null || true

            if [[ $agent_count -eq 0 ]]; then
                echo "â•‘                          No active agents                                     â•‘"
            fi

            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"

            # Check for work agent
            if [[ -f "$WORK_LOCK" ]] && kill -0 "$(cat "$WORK_LOCK" 2>/dev/null)" 2>/dev/null; then
                local work_pid=$(cat "$WORK_LOCK")
                local work_runtime=$(ps -o etime= -p "$work_pid" 2>/dev/null | tr -d ' ' || echo "??:??")
                printf "â•‘  ðŸ—ï¸  Epic Worker   â”‚ PID: %-8s â”‚ Runtime: %-10s â”‚ Implementing...  â•‘\n" \
                    "$work_pid" "$work_runtime"
            fi

            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "Press Ctrl+C to stop"
        }

        while true; do

            # Get repo info for GraphQL queries
            repo_info=$(gh repo view --json owner,name -q '.owner.login + " " + .name' 2>/dev/null)
            repo_owner=$(echo "$repo_info" | cut -d' ' -f1)
            repo_name=$(echo "$repo_info" | cut -d' ' -f2)

            # Get all open PRs
            open_prs=$(gh pr list --state open --json number -q '.[].number' 2>/dev/null || echo "")

            # Display ASCII UI
            display_status "$repo_owner" "$repo_name"

            if [[ -n "$open_prs" ]]; then
                # Count active shepherds
                active_count=0
                shopt -s nullglob 2>/dev/null || true
                for lock_file in "$STATE_DIR"/shepherd-*.lock; do
                    [[ -f "$lock_file" ]] || continue
                    if kill -0 "$(cat "$lock_file" 2>/dev/null)" 2>/dev/null; then
                        ((active_count++)) || true
                    else
                        rm -f "$lock_file" 2>/dev/null || true
                    fi
                done
                shopt -u nullglob 2>/dev/null || true

                for pr_num in $open_prs; do
                    SHEPHERD_LOCK="$STATE_DIR/shepherd-$pr_num.lock"

                    # Check if shepherd already running for this PR
                    if [[ -f "$SHEPHERD_LOCK" ]]; then
                        shepherd_pid=$(cat "$SHEPHERD_LOCK")
                        if kill -0 "$shepherd_pid" 2>/dev/null; then
                            continue
                        else
                            rm -f "$SHEPHERD_LOCK"
                        fi
                    fi

                    # Check if we're at max capacity
                    [[ $active_count -ge $MAX_CONCURRENT_SHEPHERDS ]] && continue

                    # Check PR state including unresolved comments
                    pr_state=$(gh pr view "$pr_num" --json state,statusCheckRollup,reviews \
                        -q '{state: .state, checks: [.statusCheckRollup[]? | .conclusion], reviews: [.reviews[]? | .state]}' 2>/dev/null)

                    checks_failed=$(echo "$pr_state" | grep -q '"FAILURE"\|"ERROR"\|null' && echo "yes" || echo "no")
                    has_changes_requested=$(echo "$pr_state" | grep -q '"CHANGES_REQUESTED"' && echo "yes" || echo "no")

                    # Check for unresolved review threads using GraphQL
                    unresolved_count=$(gh api graphql -f query='
                        query { repository(owner: "'"$repo_owner"'", name: "'"$repo_name"'") {
                            pullRequest(number: '"$pr_num"') {
                                reviewThreads(first: 100) {
                                    nodes { isResolved }
                                }
                            }
                        } }' --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length' 2>/dev/null || echo "0")
                    has_unresolved=$([[ "$unresolved_count" -gt 0 ]] && echo "yes" || echo "no")

                    if [[ "$checks_failed" == "yes" ]] || [[ "$has_changes_requested" == "yes" ]] || [[ "$has_unresolved" == "yes" ]]; then
                        "$0" shepherd "$pr_num" </dev/null >/dev/null 2>&1 &
                        shepherd_bg_pid=$!
                        echo "$shepherd_bg_pid" > "$SHEPHERD_LOCK"
                        ((active_count++)) || true
                    fi
                done
            fi

            # Check for pending epics/stories (only if no PRs need work)
            if ! pr_is_open; then
                if [[ -f "$WORK_LOCK" ]]; then
                    work_pid=$(cat "$WORK_LOCK")
                    if ! kill -0 "$work_pid" 2>/dev/null; then
                        rm -f "$WORK_LOCK"
                    fi
                else
                    # Find epics with uncompleted stories
                    # Check both docs/bmad/epics/ and _bmad-output/epics-*.md
                    pending_epic=""
                    shopt -s nullglob
                    for epic_file in docs/bmad/epics/*.md _bmad-output/epics-*.md; do
                        [[ -f "$epic_file" ]] || continue
                        # Check if epic has unchecked items
                        if grep -q '\- \[ \]' "$epic_file" 2>/dev/null; then
                            pending_epic="$epic_file"
                            break
                        fi
                    done
                    shopt -u nullglob

                    if [[ -n "$pending_epic" ]]; then
                        echo "[EPICS] Found pending epic: $pending_epic"
                        epic_name=$(basename "$pending_epic" .md)
                        wt_name="bmad-$(date +%s)"

                        wt_path=$(worktree_create "$wt_name")
                        cd "$wt_path"
                        claude -p "Use the Task tool with subagent_type=\"bmad-orchestrator\" to work on epic: $pending_epic

Working directory: $wt_path

When done, run: orchestrate done $wt_name" --dangerously-skip-permissions &
                        work_bg_pid=$!
                        echo "$work_bg_pid" > "$WORK_LOCK"
                        cd "$SCRIPT_DIR"
                    fi
                fi
            fi

            sleep "$LOOP_INTERVAL"
        done
        ;;

    # ==================== Interactive ====================
    interactive|int|"")
        cat <<'EOF'
Multi-Agent Orchestrator

PR Queue (one PR at a time):
  pr queue      Show queue of finished work
  pr status     Check current PR
  pr create     Create PR from queue
  done <wt>     Mark worktree done, queue for PR

Worktree Commands:
  wt create     Create worktree
  wt list       List worktrees
  wt remove     Remove worktree

Development:
  develop       Implement in worktree
  bmad          BMAD workflow
  story         Implement story
  shepherd      Watch PR
  parallel      Run parallel agents

EOF
        claude --dangerously-skip-permissions
        ;;

    help|--help|-h)
        cat <<EOF
Multi-Agent Orchestrator with PR Queue

Only ONE PR open at a time. Finished work queues for next PR.

Usage: $0 <command> [args]

Automated Loop:
  loop                    Run fully automated loop (Ctrl+C to stop)
                          - Watches/fixes open PRs
                          - Fixes build/test errors
                          - Implements pending epics
                          Set LOOP_INTERVAL=N for custom interval (default: 30s)

PR Queue Commands:
  pr set <number>         Set existing PR as current (to watch)
  pr queue                Show queued finished work
  pr status               Check current PR, process queue if closed
  pr create [wt_name]     Create PR from worktree or queue
  pr next                 Create PR from next in queue
  pr clear                Clear current PR tracking
  done <wt_name> [title]  Mark worktree done, queue for PR

Worktree Commands:
  wt create <name>        Create isolated worktree
  wt remove <name>        Remove worktree
  wt list                 List all worktrees

Development Commands:
  develop <task> [wt]     Implement in worktree
  bmad [epic] [wt]        BMAD workflow in worktree
  story <id> [wt]         Implement story in worktree
  shepherd <pr>           Watch PR, auto-fix
  review <target>         Code review
  parallel <t1> <t2>      Parallel worktrees
  spawn <agent> <task>    Spawn any agent

Workflow:
  1. orchestrate develop "Add feature" my-feature
  2. (agent works, commits)
  3. orchestrate done my-feature "Add new feature"
  4. (PR created if none open, else queued)
  5. orchestrate shepherd <pr_number>
  6. (when PR merged, next queued work creates PR)

Automated Loop Workflow:
  1. orchestrate loop     # Start automated loop
  2. (loop checks PRs, fixes issues, implements epics)
  3. Ctrl+C to stop

Examples:
  $0 loop                             # Start automated orchestration
  LOOP_INTERVAL=60 $0 loop            # Check every 60 seconds
  $0 pr set 60                        # Set existing PR #60 as current
  $0 shepherd 60                      # Watch and fix PR #60
  $0 develop "Add auth" auth-feature
  $0 done auth-feature "User authentication"
  $0 pr queue
EOF
        ;;

    *)
        echo "Unknown: $cmd. Use '$0 help'"
        exit 1
        ;;
esac
