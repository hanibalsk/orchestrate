# Property-Based Test Generation

Story 7 of Epic 005: Test Generation Agent

## Overview

The property-based test generator automatically identifies functions suitable for property testing and generates appropriate tests using:
- **Rust**: proptest
- **TypeScript**: fast-check  
- **Python**: hypothesis

## Supported Properties

### 1. Roundtrip Property
Functions that encode/decode, serialize/deserialize, parse/format data.

**Example pairs:**
- `serialize` / `deserialize`
- `encode` / `decode`
- `parse` / `format`
- `compress` / `decompress`
- `encrypt` / `decrypt`

**Generated test:**
```rust
proptest! {
    #[test]
    fn parse_serialize_roundtrip(input: String) {
        let parsed = parse(&input);
        if let Ok(value) = parsed {
            let serialized = serialize(&value);
            let reparsed = parse(&serialized).unwrap();
            assert_eq!(value, reparsed);
        }
    }
}
```

### 2. Idempotency Property
Functions that produce the same result when applied multiple times.

**Candidates:**
- `normalize`
- `sanitize`
- `clean`
- `trim`
- `sort`
- `unique`
- `dedupe`

**Generated test:**
```rust
proptest! {
    #[test]
    fn normalize_idempotent(input: String) {
        let once = normalize(&input);
        let twice = normalize(&once);
        assert_eq!(once, twice);
    }
}
```

### 3. Commutativity Property
Binary operations where order doesn't matter.

**Examples:**
- `add(a, b) == add(b, a)`
- `multiply(a, b) == multiply(b, a)`
- `max(a, b) == max(b, a)`
- `union(a, b) == union(b, a)`

**Generated test:**
```rust
proptest! {
    #[test]
    fn add_commutative(a: i32, b: i32) {
        let result1 = add(a, b);
        let result2 = add(b, a);
        assert_eq!(result1, result2);
    }
}
```

### 4. Inverse Property
Functions that reverse each other.

**Example pairs:**
- `add` / `subtract`
- `increment` / `decrement`
- `push` / `pop`
- `insert` / `remove`

**Generated test:**
```rust
proptest! {
    #[test]
    fn add_subtract_inverse(x: i32, y: i32) {
        let result = add(x, y);
        let back = subtract(result, y);
        assert_eq!(back, x);
    }
}
```

## Usage

### Generate property tests for entire file

```rust
use orchestrate_core::TestGenerationService;

let service = TestGenerationService::new();
let result = service.generate_property_tests("src/parser.rs", None).await?;

// View generated tests
let test_code = service.format_property_test_output(&result)?;
println!("{}", test_code);
```

### Generate property tests for specific function

```rust
let result = service
    .generate_property_tests("src/parser.rs", Some("serialize"))
    .await?;
```

### CLI Command (when implemented in Story 9)

```bash
# Generate property tests for all suitable functions
orchestrate test generate --type property --target src/parser.rs

# Generate for specific function
orchestrate test generate --type property --target serialize --file src/parser.rs
```

## Test File Locations

### Rust
- Location: `{source_file}_proptest.rs`
- Example: `src/parser.rs` → `src/parser_proptest.rs`

### TypeScript
- Location: `__tests__/{filename}.property.test.ts`
- Example: `src/parser.ts` → `__tests__/parser.property.test.ts`

### Python
- Location: `test_property_{filename}`
- Example: `src/parser.py` → `src/test_property_parser.py`

## Generated Output Format

### Rust (using proptest)

```rust
//! Property-based tests
//! Generated by orchestrate test generator

use proptest::prelude::*;

proptest! {
    #[test]
    fn serialize_deserialize_roundtrip(input: String) {
        let result = serialize(&input);
        if let Ok(value) = result {
            let serialized = deserialize(&value);
            let reparsed = serialize(&serialized).unwrap();
            assert_eq!(value, reparsed);
        }
    }
}

proptest! {
    #[test]
    fn normalize_idempotent(input: String) {
        let once = normalize(&input);
        let twice = normalize(&once);
        assert_eq!(once, twice);
    }
}
```

### TypeScript (using fast-check)

```typescript
// Property-based tests
// Generated by orchestrate test generator

import { test } from 'vitest';
import fc from 'fast-check';

test('serialize_deserialize_roundtrip', () => {
    fc.assert(
        fc.property(fc.string(), (input) => {
            const result = serialize(input);
            if (result !== null && result !== undefined) {
                const serialized = deserialize(result);
                const reparsed = serialize(serialized);
                expect(reparsed).toEqual(result);
            }
        })
    );
});
```

### Python (using hypothesis)

```python
"""Property-based tests
Generated by orchestrate test generator
"""

from hypothesis import given
from hypothesis import strategies as st

@given(st.text())
def test_serialize_deserialize_roundtrip(input_str):
    result = serialize(input_str)
    if result is not None:
        serialized = deserialize(result)
        reparsed = serialize(serialized)
        assert reparsed == result
```

## Benefits of Property-Based Testing

1. **Edge Case Discovery**: Automatically tests with hundreds/thousands of random inputs
2. **Shrinking**: When a test fails, the framework finds the minimal failing case
3. **Better Coverage**: Tests behavior rather than specific examples
4. **Regression Prevention**: Catches bugs that example-based tests might miss
5. **Documentation**: Properties serve as executable specifications

## Integration with Test Generation Workflow

Property tests complement other test types:

1. **Unit Tests** (Story 2): Test specific examples and edge cases
2. **Integration Tests** (Story 3): Test module interactions
3. **E2E Tests** (Story 4): Test user workflows
4. **Property Tests** (Story 7): Test mathematical properties and invariants

## Acceptance Criteria ✓

- [x] Identify functions suitable for property testing
- [x] Generate property definitions from function contracts
- [x] Use proptest (Rust), fast-check (TS), hypothesis (Python)
- [x] Generate shrinking for minimal failure cases (framework-provided)
- [x] Support `orchestrate test generate --type property --target <fn>` API

## Implementation Details

### Key Components

1. **PropertyType enum**: Defines supported property types
2. **PropertyTestCase**: Represents a generated property test
3. **PropertyTestResult**: Complete result of property test generation
4. **TestGenerationService**: Main service with property test methods

### Property Detection Algorithms

- **Roundtrip**: Name pattern matching (serialize/deserialize, encode/decode, etc.)
- **Idempotency**: Keyword matching (normalize, trim, sanitize, etc.) + return type check
- **Commutativity**: Binary function + operation name (add, multiply, max, etc.)
- **Inverse**: Name pattern matching (add/subtract, push/pop, etc.)

## Example Usage

See `/tmp/example_property_test.rs` and `/tmp/test_property_demo.rs` for working examples.

## Testing

75+ comprehensive tests covering:
- Property detection (roundtrip, idempotency, commutativity, inverse)
- Code generation for Rust, TypeScript, Python
- File path determination
- Output formatting
- Integration tests with real files

Run tests:
```bash
cargo test --package orchestrate-core --lib test_generation::tests
```
